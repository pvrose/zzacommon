#pragma once

#include <fstream>
#include <istream>
#include <map>
#include <ostream>
#include <string>

//! Reset configuration files
extern uint16_t DEBUG_RESET_CONFIG;

//! File control structore
struct file_control_t {
	std::string filename;                   //!< Filename.
	bool reference;                         //!< file is reference - from source.
	bool read_only;                         //!< Not written - do not copy from source.
	uint16_t reset_mask;                    //!< Reset mask.
	bool fatal{ true };                     //!< Fatal error if unable to open the file.
};

//! \brief File contents.
//! The user should create another enum based on uint8_t with the first entry starting
//! at FILE_USER.
//! \code
//! enum user_file_t : uint8_t {
//!   FILE_TYPE_A = FILE_USER,
//!   FILE_TYPE_B
//! }
//! \endcode
enum file_contents_t : uint8_t {
	FILE_ICON_ZZA,                          //!< Always have an icon
	FILE_STATUS,                            //!< Conditionally have a status log
	FILE_SETTINGS,                          //!< Conditionally have a settings file
	FILE_USER = 16                          //!< Provide some free space for m ore
};

//! Data type for getting directory 
enum file_data_t : uint8_t {
	DATA_WORKING,               //!< Working directory
    DATA_SOURCE,                //!< Original source directory
	DATA_CODEGEN,               //!< Directory for generated code
	DATA_HTML,                  //!< Directory for HTML & PDF (userguide and code docs)
};

//! Forward declaration to self
class file_holder;
extern file_holder* file_holder_;

//! \brief This class provides a general interface to allow a standard use of application-specific data.
//! Data is classed as one of the following:
//! \par DATA_SOURCE: 
//! Data that is provided with the installation of the app. Data that is only ever read
//! will be kept in this directory: other data will be moved to DATA_WORKING.
//! During development this data will be in the same directory as the application executable.
//! Otherwise this data will be in C:\\ProgramData\\[vendor]\\[app] directory (Windows)
//! or /etc/[vendor]/[app] directory (Linux).
//! \par DATA_WORKING: 
//! Data that is generated by the app, or is provided with the installation but can be
//! modified by the app.
//! This data will be in C:\\users\\[username]\\AppData\\Roaming\\[vendor]\\[app] directory (Windows)
//! or /home/[username]/.config/[vendor]/[app] directory (Linux).
//! \par DATA_CODE: 
//! Not used.
//! \par DATA_HTML: 
//! Files that make up the user and developer documentation.
//! This location is the same as DATA_SOURCE.
class file_holder
{
public:
	//! \brief Constructor.
	//! \param arg0 This is arg[0] provided in the call to main() in the user app. It 
	//! containes the path to the executable from the current working directory.
	//! \param control This provides the control data to define the files and their type:
	/*!
	\code
    const std::map < uint8_t, file_control_t > FILE_CONTROL = {
		// ID, { filename, reference, read-only, reset-flag }
		{ FILE_ADIF, { "all.json", true, true, DEBUG_RESET_ADIF } },
		{ FILE_BANDPLAN, { "band_plan.json", true, false, DEBUG_RESET_BAND } },
		{ FILE_COUNTRY_CLUB, { "cty.xml", true, false, DEBUG_RESET_CTY } },
		{ FILE_COUNTRY_CFILES, { "cty.csv", true, false, DEBUG_RESET_CTY1 }},
		{ FILE_COUNTRY_DXATLAS, { "Prefix.lst", true, false, DEBUG_RESET_CTY2 }},
		{ FILE_COUNTRY, { "cty.json", true, false, DEBUG_RESET_CTY3, false } },
		{ FILE_INTLCHARS, { "intl_chars.txt", true, false, DEBUG_RESET_INTL }},
		{ FILE_ICON_GMAPS, { "google-maps.png", true, true, DEBUG_RESET_ICON }},
		{ FILE_ICON_PDF, { "pdf.png", true, true, DEBUG_RESET_ICON}},
		{ FILE_ICON_QRZ, { "qrz_1.jpg", true, true, DEBUG_RESET_ICON}},
		{ FILE_APPS, { "apps.json", false, false, DEBUG_RESET_APPS}},
		{ FILE_SETTINGS, { "ZZALOG.json", false, false, DEBUG_RESET_SETT }},
		{ FILE_RIGS, { "rigs.json", false, false, DEBUG_RESET_RIGS }},
		{ FILE_FIELDS, { "fields.json", false, false, DEBUG_RESET_FLDS}},
		{ FILE_CONTEST, { "contests.json", false, false, DEBUG_RESET_TEST }},
		{ FILE_SOLAR, { "solar.xml", false, false, 0}},
		{ FILE_STATUS, { "status.txt", false, false, 0}},
		{ FILE_STATION, { "station.json", false, false, DEBUG_RESET_STN }},
		{ FILE_ICON_ZZA, { "rose.png", true, true, 0}}
	};
	\endcode
	\note Information must be provided for the files used in settings and status if these
	are used (FILE_ICON_ZZA, FILE_SETTINGS and FILE_STATUS) \see file_contents_t.
	*/
	file_holder(const char* arg0, const std::map<uint8_t, file_control_t>& control);

	//! Destructor
	~file_holder() {};

	//! \brief Get file for input.
	//! \param type File contents
	//! \param is Returned input stream
	//! \param filename Returns name of opened file
	//! \returns true if successful
	bool get_file(uint8_t type, std::ifstream& is, std::string& filename);

	//! \brief Get file for output.
	//! \param type File contents
	//! \param os Returned input stream
	//! \param filename Returns name of opened file
	//! \returns true if successful
	bool get_file(uint8_t type, std::ofstream& os, std::string& filename) const;

	//! Get filename for data \p type.
	std::string get_filename(uint8_t type) {
		const file_control_t ctrl = control_data_.at(type);
		if (ctrl.read_only) return default_source_directory_ + ctrl.filename;
		else return default_data_directory_ + ctrl.filename;
	}

	//! Get directory for data \p type.
	std::string get_directory(file_data_t type) {
		switch (type) {
		case DATA_WORKING: return default_data_directory_;
		case DATA_SOURCE: return default_source_directory_;
		case DATA_CODEGEN: return default_code_directory_;
		case DATA_HTML: return default_html_directory_;
		default: return "";
		}
	}

	//! \brief Release working copy to source. 
	//! \note This is only available for development use. 
	bool copy_working_to_source(uint8_t type) const;

	//! Get file control for type.
	file_control_t file_control(uint8_t type) const;

protected:

	//! Copy source to working.
	bool copy_source_to_working(file_control_t ctrl) const;
	

	//! Default location for configuration files, and HTML files.
	std::string default_data_directory_;

	//! Default location for reference source data.
	std::string default_source_directory_;

	//! Default location for auto-generating compile fodder.
	std::string default_code_directory_;

	//! Default directory for HTML files.
	std::string default_html_directory_;

	//! Control data.
	std::map<uint8_t, file_control_t> control_data_;


};
